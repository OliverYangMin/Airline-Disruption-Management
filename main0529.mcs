require '01Class.Flight'
require '01Class.Aircraft'
require '01Class.Airport'
require '01Class.Delta'
require '01Class.Route'
--require '01Class.Label'
require '02Module.stdlib'
require '02Module.GetData'  --load the data get: flights, airports, aircrafts and nodes, crafts
PORT1               = 57
CTIME1              = 480
OTIME1              = 600

Label = {}
Label.__index = Label

function Label:new(tab)
    local self = tab or {0; cost = 0, delay = 0, cut = 0, cuts = {}}
    setmetatable(self, Label)
    return self
end 

function Label:newDelay(flight1, flight2, gtime)
    return math.max(0, flight1.time2 + self.delay + gtime - flight2.time1)
end

function Label:dominate(label)
    if #self == #label then 
        for i=2,#self-1 do
            if self[i] ~= label[i] then 
                return false
            end 
        end 
        return self.cost <= label.cost  and self.cut <= label.cut 
    end 
end 

function Label:extend(id, craft)
    local flight1, flight2 = flights[self[#self]], flights[id]
    
    if id > 0 then 
        for t=1,3 do 
            local tab = {unpack(self)}
            tab[#tab+1] = id
            tab.cut, tab.cuts = self.cut, DeepCopy(self.cuts)
            local tag = Label:new(tab) --{unpack(self), index; cut = self.cut, cuts = DeepCopy(self.cuts)}  
            local cut2 = 0
            if t == 1 then 
                tag.delay = self:newDelay(flight1, flight2, flight1.gtime)
            elseif self.delay + flight1.time2 + flight1.gtime > flight2.time1 then
                if t==2 then
                    if flight1.gtime > airports[flight1.port2].turn[craft.atp] then  
                        tag.delay = self:newDelay(flight1, flight2, airports[flight1.port2].turn[craft.atp])
                    else
                        goto continue
                    end 
                elseif t==3 then
                    if flight1.gtime > math.ceil(airports[flight1.port2].turn[craft.atp] * 2 / 3) then  
                        tag.delay = self:newDelay(flight1, flight2, math.ceil(airports[flight1.port2].turn[craft.atp] * 2 / 3))
                        cut2 = math.min(math.floor(airports[flight1.port2].turn[craft.atp] / 3), airports[flight1.port2].turn[craft.atp] - flight2.time1 + flight1.time2 + self.delay)
                    else 
                        break
                    end 
                end 
                tag.cut = tag.cut + 1
                tag.cuts[#self-1] = cut2
            else 
                break
            end 
            

            if tag.delay > 1440 or not delta:checkAirport(flight2, tag.delay) then 
                break 
            end 

            tag.cost = self.cost + delta:flightDelay(flight2, tag.delay) + delta:swapCraft(flight2, craft) + cut2 * 20   --- -flight2.dual    
            
            for i=#flight2.labels,1,-1 do
                if flight2.labels[i]:dominate(tag) then
                    break 
                elseif tag:dominate(flight2.labels[i]) then
                    table.remove(flight2.labels, i)
                end 
            end 
            
            flight2.labels[#flight2.labels+1] = tag
            if tag.delay == 0 then 
                break 
            end 
            ::continue::
        end 
    else
        local tab = {unpack(self)}
        tab[#tab+1] = id
        tab.cut, tab.cuts, tab.cost,tab.delay = self.cut, DeepCopy(self.cuts), self.cost ,self.delay
        local tag = Label:new(tab)--{unpack(self), cost = self.cost, delay = self.delay, cut = self.cut, cuts = DeepCopy(self.cuts)}
--        if tag.delay + flight1.time2 + flight1.gtime > craft.day2 then
--            tag.cut = tag.cut + 1
--            local cut2 = math.max(0, flight1.time2 + tag.delay + airports[flight1.port2].turn[craft.atp] - craft.day2)
--            tag.cost = tag.cost + cut2 * 20 
--            table.insert(tag.cuts, cut2)
--        end 
        table.insert(flights[id].labels, tag)
    end 
end 

function Label:to_route(craft)
    local route = Route:new(craft)
    for i=2,#self do
        route:append(self[i])
    end 
    
    route.cost = self.cost - craft.dual 
    for i=1,#route do
        route.cost = route.cost - flights[route[i]].dual
    end 
    return route
end 

function main()
    require 'mobdebug'.off()
    P = {} --cost weight
    P[1] = 1800 --flight cancel cost
    P[2] = 1200 --flight delay cost
    P[3] = 2000 --aircraft base changed cost
    P[4] = 300  --flight aircraft type changed cost
    type_type_matrix = {{0,1,2,3}, {1,0,1.5,2.5}, {2,1.5,0,2}, {3,2.5,2,0}}
    P[5] = 30 / 60   --total delay time cost  --minutes
    P[6] = 6 --passenger cancel cost
    P[7] = {1, 1.5, 2, 3, 5} --passenger delay cost
    P[8] = {1/60/60, 1/48/60, 1/36/60, 1/24/60, 1/12/60} --passenger change cost
    P[9] = 1200 --turnaround time change cost
    
    GetData() 
    -- 第一步只考虑第一天的航班
    for i=#flights,1,-1 do
        if flights[i].date > 1 then
            table.remove(flights, i)
        end 
    end 
        
    for c,craft in pairs(aircrafts) do
        for i=#craft.rot,1,-1 do
            if craft.rot[i].date == 1 then 
                break
            else 
                craft.rot[i] = nil 
            end 
        end 
    end 
    require 'mobdebug'.on()
    local starttime = os.clock()
    delta = Delta:new()
    
    craft = aircrafts[5]
    --for _,craft in pairs(aircrafts) do
        craft:buildGraph()
    --end 
    

    for i=1,#craft.order do
        for _,label in ipairs(flights[craft.fSet[craft.order[i]]].labels) do
            for a,adj in ipairs(craft.adj[craft.order[i]]) do
                label:extend(adj, craft)
            end 
        end 
    end 
  
    local routes = {}
    for _,label in ipairs(flights[-1].labels) do
        routes[#routes+1] = label:to_route(craft)
    end 
    
--repeat
--    local master = Master:new()
--    master:solve()
--    master:setDuals()
--    local routes = master:solveSubproblem()
--    for i=1,#routes do
--        master.routes[#master.routes+1] = routes[i]
--    end 
--until #routes == 0
    print(os.clock() - starttime)
end 

main()